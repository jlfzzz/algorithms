======================================
 动态规划问题要点总结
======================================

---
1. 打家劫舍 (House Robber) 系列
---

核心问题: 从一系列物品/房屋中选择，相邻的不能同时选，求最大价值/总和。

DP状态定义 (一维):
*   `dp[i]` 通常表示: 考虑前 `i` 个房屋，并且**必须偷第 `i` 个房屋**时能获得的最大金额。
*   或者 `dp[i]` 表示: 考虑前 `i` 个房屋（**不一定偷第 `i` 个**）能获得的最大金额。 (这种定义更常见)

状态转移方程 (基于第二种定义):
*   `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`
    *   `dp[i-1]`: 不偷第 `i` 个房屋，最大金额等于偷到 `i-1` 的最大金额。
    *   `dp[i-2] + nums[i]`: 偷第 `i` 个房屋，则不能偷 `i-1`，最大金额等于偷到 `i-2` 的最大金额加上第 `i` 个房屋的金额 `nums[i]`。

边界条件:
*   `dp[0] = nums[0]`
*   `dp[1] = max(nums[0], nums[1])`

空间优化:
*   由于 `dp[i]` 只依赖于 `dp[i-1]` 和 `dp[i-2]`，可以使用滚动数组或两个变量优化空间至 O(1)。

变种:
*   环形数组 (首尾相连): 分两种情况计算，取最大值：
    1.  不偷第一家，计算 `nums[1...n-1]` 的最大金额。
    2.  不偷最后一家，计算 `nums[0...n-2]` 的最大金额。
*   树形结构 (打家劫舍 III): 使用树形 DP，通常定义一个返回大小为 2 的数组/pair 的递归函数 `dfs(node)`，`result[0]` 表示不偷当前节点的最大值，`result[1]` 表示偷当前节点的最大值。

---
2. 背包问题 (Knapsack) 系列
---

核心问题: 给定一组物品（有重量/体积和价值）和一个背包容量，选择物品放入背包，使得总价值最大，且总重量/体积不超过容量。

DP状态定义 (二维):
*   `dp[i][j]` 通常表示: 从前 `i` 个物品中选择，放入容量为 `j` 的背包中所能获得的最大价值。

状态转移方程 (0/1 背包 - 每件物品只能选一次):
*   `dp[i][j] = dp[i-1][j]` (不选第 `i` 个物品)
*   `dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i])` (如果 `j >= weight[i]`)
    *   比较不选第 `i` 个物品 和 选第 `i` 个物品 的价值。

状态转移方程 (完全背包 - 每件物品可以选无限次):
*   `dp[i][j] = dp[i-1][j]` (不选第 `i` 个物品)
*   `dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i]] + value[i])` (如果 `j >= weight[i]`)
    *   注意区别：选第 `i` 个物品时，依赖的是 `dp[i][...]` 而不是 `dp[i-1][...]`，表示可以重复选第 `i` 个。
*   或者优化后的一维 DP (物品放外循环，容量放内循环且**正序**遍历):
    *   `dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`

空间优化 (0/1 背包):
*   可以使用一维数组 `dp[j]`，但内层循环（容量 `j`）必须**倒序**遍历，防止物品被重复计算。
    *   `dp[j] = max(dp[j], dp[j - weight[i]] + value[i])` (for j from capacity down to weight[i])

其他变种:
*   多重背包: 每种物品有有限件。可以转化为 0/1 背包，或使用二进制优化/单调队列优化。
*   恰好装满: 初始化 `dp` 数组为负无穷（除了 `dp[0]=0`），最后判断 `dp[capacity]` 是否为非负无穷。
*   求方案数: 将 `max` 操作改为 `sum` 操作。
*   求最小重量/代价: 类似，但 `dp` 定义和转移方程的目标是最小化。

---
3. Kadane 算法 (最大子数组和)
---

核心问题: 找到一个具有最大和的连续子数组（子数组最少包含一个元素）。

DP状态定义 (一维，通常不显式写出 dp 数组):
*   `current_max_ending_here` (或 `f[i]`) 表示: 以当前元素 `nums[i]` **结尾**的最大连续子数组和。

状态转移方程:
*   `current_max_ending_here = max(nums[i], current_max_ending_here + nums[i])`
    *   要么自成一段 (从 `nums[i]` 开始)，要么连接到前面的最大和子数组。

求解最终结果:
*   需要一个额外的变量 `global_max` (或 `max_so_far`) 来记录遍历过程中遇到的所有 `current_max_ending_here` 的最大值。
*   最终返回 `global_max`，而不是循环结束时的 `current_max_ending_here`。

空间优化:
*   天然是 O(1) 空间复杂度，只需要 `current_max_ending_here` 和 `global_max` 两个变量。

变种:
*   环形数组最大子数组和:
    1.  计算非环形的最大子数组和 `max_kadane`。
    2.  计算数组总和 `total_sum`。
    3.  计算最小子数组和 `min_kadane` (可以通过 Kadane 找 `-nums[i]` 的最大和再取反，或者直接写最小和的 Kadane)。
    4.  环形的最大和是 `total_sum - min_kadane` (注意: 这只有在 `min_kadane` 不是整个数组总和时才有意义)。
    5.  最终结果是 `max(max_kadane, total_sum - min_kadane)`。
    6.  特殊处理: 如果所有数都是负数，`max_kadane` 就是结果 (此时 `total_sum == min_kadane`)。

---
4. 最长公共子序列 (LCS - Longest Common Subsequence)
---

核心问题: 找到两个序列共有的、最长的子序列的长度（子序列不需要连续）。

DP状态定义 (二维):
*   `dp[i][j]` 表示: 字符串 `text1` 的前 `i` 个字符 (`text1[0...i-1]`) 与字符串 `text2` 的前 `j` 个字符 (`text2[0...j-1]`) 的最长公共子序列的长度。

状态转移方程:
*   如果 `text1[i-1] == text2[j-1]`:
    *   `dp[i][j] = dp[i-1][j-1] + 1` (当前字符匹配，LCS 长度加 1)
*   如果 `text1[i-1] != text2[j-1]`:
    *   `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` (当前字符不匹配，LCS 长度等于去掉 `text1` 当前字符 或 去掉 `text2` 当前字符 后的 LCS 长度的最大值)

边界条件:
*   `dp[0][j] = 0` for all `j`
*   `dp[i][0] = 0` for all `i`

最终结果:
*   `dp[m][n]`，其中 `m` 是 `text1` 的长度，`n` 是 `text2` 的长度。

空间优化:
*   可以使用滚动数组或两个一维数组优化空间至 O(min(m, n))。

---
5. 最长递增子序列 (LIS - Longest Increasing Subsequence)
---

核心问题: 找到一个序列中单调递增的最长子序列的长度（子序列不需要连续）。

DP状态定义 (一维):
*   `dp[i]` 表示: 以 `nums[i]` **结尾**的最长递增子序列的长度。

状态转移方程:
*   `dp[i] = 1 + max(dp[j])` for all `0 <= j < i` and `nums[j] < nums[i]`。
*   如果找不到满足 `nums[j] < nums[i]` 的 `j`，则 `dp[i] = 1`。
*   **实现时通常这样写:**
    ```
    dp[i] = 1; // 初始化为 1 (至少包含自身)
    for (int j = 0; j < i; ++j) {
        if (nums[j] < nums[i]) {
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
    ```

最终结果:
*   **不是 `dp[n-1]`！** 而是 `max(dp[0], dp[1], ..., dp[n-1])`。因为最长递增子序列不一定以最后一个元素结尾。

时间复杂度:
*   O(N^2)

优化方法 (耐心排序法 - Patience Sorting):
*   使用一个辅助数组 `tails` (或 `min_last`)，`tails[k]` 存储长度为 `k+1` 的所有递增子序列中末尾元素的最小值。
*   遍历 `nums`，对于每个 `num`：
    *   如果 `num` 大于 `tails` 中所有元素，则将其附加到 `tails` 末尾 (LIS 长度加 1)。
    *   否则，使用二分查找在 `tails` 中找到第一个大于等于 `num` 的元素 `tails[k]`，并用 `num` 替换它 (`tails[k] = num`)。这表示我们找到了一个长度为 `k+1` 的、但结尾更小的递增子序列，未来可能有更多元素接在它后面。
*   最终 `tails` 数组的长度就是 LIS 的长度。
*   时间复杂度: O(N log N)

---
End of Summary
---